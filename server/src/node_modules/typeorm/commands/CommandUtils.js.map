{"version":3,"sources":["../../src/commands/CommandUtils.ts"],"names":[],"mappings":"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","file":"CommandUtils.js","sourcesContent":["import * as fs from \"fs\"\nimport * as path from \"path\"\nimport mkdirp from \"mkdirp\"\nimport { TypeORMError } from \"../error\"\nimport { DataSource } from \"../data-source\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { importOrRequireFile } from \"../util/ImportUtils\"\n\n/**\n * Command line utils functions.\n */\nexport class CommandUtils {\n    static async loadDataSource(\n        dataSourceFilePath: string,\n    ): Promise<DataSource> {\n        let dataSourceFileExports\n        try {\n            ;[dataSourceFileExports] = await importOrRequireFile(\n                dataSourceFilePath,\n            )\n        } catch (err) {\n            throw new Error(\n                `Unable to open file: \"${dataSourceFilePath}\". ${err.message}`,\n            )\n        }\n\n        if (\n            !dataSourceFileExports ||\n            typeof dataSourceFileExports !== \"object\"\n        ) {\n            throw new Error(\n                `Given data source file must contain export of a DataSource instance`,\n            )\n        }\n\n        const dataSourceExports = []\n        for (const fileExportKey in dataSourceFileExports) {\n            const fileExport = dataSourceFileExports[fileExportKey]\n            // It is necessary to await here in case of the exported async value (Promise<DataSource>).\n            // e.g. the DataSource is instantiated with an async factory in the source file\n            const awaitedFileExport =\n                fileExport instanceof Promise ? await fileExport : fileExport\n            if (InstanceChecker.isDataSource(awaitedFileExport)) {\n                dataSourceExports.push(awaitedFileExport)\n            }\n        }\n\n        if (dataSourceExports.length === 0) {\n            throw new Error(\n                `Given data source file must contain export of a DataSource instance`,\n            )\n        }\n        if (dataSourceExports.length > 1) {\n            throw new Error(\n                `Given data source file must contain only one export of DataSource instance`,\n            )\n        }\n        return dataSourceExports[0]\n    }\n\n    /**\n     * Creates directories recursively.\n     */\n    static createDirectories(directory: string) {\n        return mkdirp(directory)\n    }\n\n    /**\n     * Creates a file with the given content in the given path.\n     */\n    static async createFile(\n        filePath: string,\n        content: string,\n        override: boolean = true,\n    ): Promise<void> {\n        await CommandUtils.createDirectories(path.dirname(filePath))\n        return new Promise<void>((ok, fail) => {\n            if (override === false && fs.existsSync(filePath)) return ok()\n\n            fs.writeFile(filePath, content, (err) => (err ? fail(err) : ok()))\n        })\n    }\n\n    /**\n     * Reads everything from a given file and returns its content as a string.\n     */\n    static async readFile(filePath: string): Promise<string> {\n        return new Promise<string>((ok, fail) => {\n            fs.readFile(filePath, (err, data) =>\n                err ? fail(err) : ok(data.toString()),\n            )\n        })\n    }\n\n    static async fileExists(filePath: string) {\n        return fs.existsSync(filePath)\n    }\n\n    /**\n     * Gets migration timestamp and validates argument (if sent)\n     */\n    static getTimestamp(timestampOptionArgument: any): number {\n        if (\n            timestampOptionArgument &&\n            (isNaN(timestampOptionArgument) || timestampOptionArgument < 0)\n        ) {\n            throw new TypeORMError(\n                `timestamp option should be a non-negative number. received: ${timestampOptionArgument}`,\n            )\n        }\n        return timestampOptionArgument\n            ? new Date(Number(timestampOptionArgument)).getTime()\n            : Date.now()\n    }\n}\n"],"sourceRoot":".."}