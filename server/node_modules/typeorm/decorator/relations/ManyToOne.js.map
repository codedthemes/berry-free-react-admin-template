{"version":3,"sources":["../../src/decorator/relations/ManyToOne.ts"],"names":[],"mappings":";;;AAAA,2CAAsD;AAItD,wDAAoD;AAuBpD;;;;GAIG;AACH,SAAgB,SAAS,CACrB,oBAA8D,EAC9D,oBAAsE,EACtE,OAAyB;IAEzB,wBAAwB;IACxB,IAAI,mBAAkD,CAAA;IACtD,IAAI,yBAAW,CAAC,QAAQ,CAAC,oBAAoB,CAAC,EAAE;QAC5C,OAAO,GAAoB,oBAAoB,CAAA;KAClD;SAAM;QACH,mBAAmB,GAAG,oBAA2B,CAAA;KACpD;IAED,OAAO,UAAU,MAAc,EAAE,YAAoB;QACjD,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAqB,CAAA;QAE7C,iDAAiD;QACjD,IAAI,MAAM,GAAG,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,CAAA;QAC7C,IAAI,CAAC,MAAM,IAAI,OAAO,IAAK,OAAe,CAAC,WAAW,EAAE;YACpD,0BAA0B;YAC1B,MAAM,aAAa,GAAI,OAAe,CAAC,WAAW,CAC9C,aAAa,EACb,MAAM,EACN,YAAY,CACf,CAAA;YACD,IACI,aAAa;gBACb,OAAO,aAAa,CAAC,IAAI,KAAK,QAAQ;gBACtC,aAAa,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,SAAS;gBAE9C,MAAM,GAAG,IAAI,CAAA;SACpB;QAED,IAAA,gCAAsB,GAAE,CAAC,SAAS,CAAC,IAAI,CAAC;YACpC,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,YAAY,EAAE,YAAY;YAC1B,+BAA+B;YAC/B,YAAY,EAAE,aAAa;YAC3B,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,oBAAoB;YAC1B,mBAAmB,EAAE,mBAAmB;YACxC,OAAO,EAAE,OAAO;SACK,CAAC,CAAA;IAC9B,CAAC,CAAA;AACL,CAAC;AA5CD,8BA4CC","file":"ManyToOne.js","sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { ObjectType } from \"../../common/ObjectType\"\nimport { RelationOptions } from \"../options/RelationOptions\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but\n * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of\n * Entity2 on its side of the relation.\n */\nexport function ManyToOne<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    options?: RelationOptions,\n): PropertyDecorator\n\n/**\n * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but\n * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of\n * Entity2 on its side of the relation.\n */\nexport function ManyToOne<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    inverseSide?: string | ((object: T) => any),\n    options?: RelationOptions,\n): PropertyDecorator\n\n/**\n * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but\n * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of\n * Entity2 on its side of the relation.\n */\nexport function ManyToOne<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    inverseSideOrOptions?: string | ((object: T) => any) | RelationOptions,\n    options?: RelationOptions,\n): PropertyDecorator {\n    // Normalize parameters.\n    let inverseSideProperty: string | ((object: T) => any)\n    if (ObjectUtils.isObject(inverseSideOrOptions)) {\n        options = <RelationOptions>inverseSideOrOptions\n    } else {\n        inverseSideProperty = inverseSideOrOptions as any\n    }\n\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // Now try to determine if it is a lazy relation.\n        let isLazy = options && options.lazy === true\n        if (!isLazy && Reflect && (Reflect as any).getMetadata) {\n            // automatic determination\n            const reflectedType = (Reflect as any).getMetadata(\n                \"design:type\",\n                object,\n                propertyName,\n            )\n            if (\n                reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\"\n            )\n                isLazy = true\n        }\n\n        getMetadataArgsStorage().relations.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            // propertyType: reflectedType,\n            relationType: \"many-to-one\",\n            isLazy: isLazy,\n            type: typeFunctionOrTarget,\n            inverseSideProperty: inverseSideProperty,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"],"sourceRoot":"../.."}